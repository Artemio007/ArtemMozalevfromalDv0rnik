Задание 2(I).
Напишите декоратор @timer для функции поиска n-го числа Фибоначчи, который будет выводить время выполнения программы.
Задание 3(I). Написать декоратор @do_twice, который будет вызывать любую функцию дважды.
Задание 4(I). Реализуйте декоратор @call_once, который запускает функцию или метод один раз и кэширует (сохраняет) результат.
Все последовательные вызовы этой функции должны возвращать кэшированный результат независимо от аргументов

@call_once
def sum_of_numbers(a, b):
    return a + b

print(sum_of_numbers(13, 42))
>>> 55
print(sum_of_numbers(999, 100))
>>> 55

Задание 5(I). Пусть дана следующая функция:

def transform(list1, list2):
    result = []
    for i in list1:
       for j in list2:
           result.append(f"{i} + {j}")
    return result

Напишите декоратор @reverse_list, который будет возвращать список обратный списку из функции выше.
Выполните оптимизацию функции transform(list1, list2), если это возможно.
